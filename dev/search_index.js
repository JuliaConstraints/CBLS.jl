var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CBLS","category":"page"},{"location":"#CBLS","page":"Home","title":"CBLS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CBLS.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CBLS]","category":"page"},{"location":"#CBLS.AllDifferent","page":"Home","title":"CBLS.AllDifferent","text":"Global constraint ensuring that all the values of a given configuration are unique.\n\n@constraint(model, X in AllDifferent())\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.AllEqual","page":"Home","title":"CBLS.AllEqual","text":"Global constraint ensuring that all the values of X are all equal.\n\n@constraint(model, X in AllEqual())\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.AllEqualParam","page":"Home","title":"CBLS.AllEqualParam","text":"Global constraint ensuring that all the values of X are all equal to a given parameter param.\n\n@constraint(model, X in AllEqualParam(param))\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.AlwaysTrue","page":"Home","title":"CBLS.AlwaysTrue","text":"Always return true. Mainly used for testing purpose.\n\n@constraint(model, X in AlwaysTrue())\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.DiscreteSet","page":"Home","title":"CBLS.DiscreteSet","text":"DiscreteSet(values)\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.DistDifferent","page":"Home","title":"CBLS.DistDifferent","text":"Local constraint ensuring that, given a vector X of size 4, |X[1] - X[2]| ≠ |X[3] - X[4]|).\n\n@constraint(model, X in DistDifferent())\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.Eq","page":"Home","title":"CBLS.Eq","text":"Equality between two variables.\n\n@constraint(model, X in Eq())\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.Error","page":"Home","title":"CBLS.Error","text":"Error{F <: Function} <: JuMP.AbstractVectorSet\n\nThe solver will compute a straightforward error function based on the concept. To run the solver efficiently, it is possible to provide an error function err instead of concept. err must return a nonnegative real number.\n\n@constraint(model, X in Error(err))\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.LessThanParam","page":"Home","title":"CBLS.LessThanParam","text":"Constraint ensuring that the value of x is less than a given parameter param.\n\n@constraint(model, x in LessThanParam(param))\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOIAllDifferent","page":"Home","title":"CBLS.MOIAllDifferent","text":"MOIAllDifferent <: MOI.AbstractVectorSet\n\nDOCSTRING\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOIAllEqual","page":"Home","title":"CBLS.MOIAllEqual","text":"MOIAllEqual <: MOI.AbstractVectorSet\n\nDOCSTRING\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOIAllEqualParam","page":"Home","title":"CBLS.MOIAllEqualParam","text":"MOIAllEqualParam{T <: Number} <: MOI.AbstractVectorSet\n\nDOCSTRING\n\nArguments:\n\nparam::T: DESCRIPTION\ndimension::Int: DESCRIPTION\nMOIAllEqualParam(param, dim = 0) = begin       #= none:5 =#       new{typeof(param)}(param, dim)   end: DESCRIPTION\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOIAlwaysTrue","page":"Home","title":"CBLS.MOIAlwaysTrue","text":"MOIAlwaysTrue <: MOI.AbstractVectorSet\n\nDOCSTRING\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOIDistDifferent","page":"Home","title":"CBLS.MOIDistDifferent","text":"MOIDistDifferent <: MOI.AbstractVectorSet\n\nDOCSTRING\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOIEq","page":"Home","title":"CBLS.MOIEq","text":"MOIEq <: MOI.AbstractVectorSet\n\nDOCSTRING\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOIError","page":"Home","title":"CBLS.MOIError","text":"MOIError{F <: Function} <: MOI.AbstractVectorSet\n\nDOCSTRING\n\nArguments:\n\nf::F: DESCRIPTION\ndimension::Int: DESCRIPTION\nMOIError(f, dim = 0) = begin       #= none:5 =#       new{typeof(f)}(f, dim)   end: DESCRIPTION\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOILessThanParam","page":"Home","title":"CBLS.MOILessThanParam","text":"MOILessThanParam{T <: Number} <: MOI.AbstractVectorSet\n\nDOCSTRING\n\nArguments:\n\nparam::T: DESCRIPTION\ndimension::Int: DESCRIPTION\nMOILessThanParam(param, dim = 0) = begin       #= none:5 =#       new{typeof(param)}(param, dim)   end: DESCRIPTION\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOIMinusEqualParam","page":"Home","title":"CBLS.MOIMinusEqualParam","text":"MOIMinusEqualParam{T <: Number} <: MOI.AbstractVectorSet\n\nDOCSTRING\n\nArguments:\n\nparam::T: DESCRIPTION\ndimension::Int: DESCRIPTION\nMOIMinusEqualParam(param, dim = 0) = begin       #= none:5 =#       new{typeof(param)}(param, dim)   end: DESCRIPTION\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOIOrdered","page":"Home","title":"CBLS.MOIOrdered","text":"MOIOrdered <: MOI.AbstractVectorSet\n\nDOCSTRING\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOIPredicate","page":"Home","title":"CBLS.MOIPredicate","text":"MOIPredicate{F <: Function} <: MOI.AbstractVectorSet\n\nDOCSTRING\n\nArguments:\n\nf::F: DESCRIPTION\ndimension::Int: DESCRIPTION\nMOIPredicate(f, dim = 0) = begin       #= none:5 =#       new{typeof(f)}(f, dim)   end: DESCRIPTION\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOISequentialTasks","page":"Home","title":"CBLS.MOISequentialTasks","text":"MOISequentialTasks <: MOI.AbstractVectorSet\n\nDOCSTRING\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MOISumEqualParam","page":"Home","title":"CBLS.MOISumEqualParam","text":"MOISumEqualParam{T <: Number} <: MOI.AbstractVectorSet\n\nDOCSTRING\n\nArguments:\n\nparam::T: DESCRIPTION\ndimension::Int: DESCRIPTION\nMOISumEqualParam(param, dim = 0) = begin       #= none:5 =#       new{typeof(param)}(param, dim)   end: DESCRIPTION\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.MinusEqualParam","page":"Home","title":"CBLS.MinusEqualParam","text":"Constraint ensuring that the value of x is less than a given parameter param.\n\n@constraint(model, x in MinusEqualParam(param))\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.Optimizer","page":"Home","title":"CBLS.Optimizer","text":"Optimizer <: MOI.AbstractOptimizer\n\nDOCSTRING\n\nArguments:\n\nsolver::Solver: DESCRIPTION\nstatus::MOI.TerminationStatusCode: DESCRIPTION\noptions::Options: DESCRIPTION\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.Optimizer-2","page":"Home","title":"CBLS.Optimizer","text":"Optimizer(model = Model(); options = Options())\n\nDOCSTRING\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.Ordered","page":"Home","title":"CBLS.Ordered","text":"Global constraint ensuring that all the values of x are ordered.\n\n@constraint(model, X in Ordered())\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.Predicate","page":"Home","title":"CBLS.Predicate","text":"Predicate{F <: Function} <: JuMP.AbstractVectorSet\n\nAssuming X is a (collection of) variables, concept a boolean function over X, and that a model is defined. In JuMP syntax we can create a constraint based on concept as follows.\n\n@constraint(model, X in Predicate(concept))\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.ScalarFunction","page":"Home","title":"CBLS.ScalarFunction","text":"ScalarFunction{F <: Function, V <: Union{Nothing, VOV}} <: MOI.AbstractScalarFunction\n\nA container to express any function with real value in JuMP syntax. Used with the @objective macro.\n\nArguments:\n\nf::F: function to be applied to X\nX::V: a subset of the variables of the model.\n\nGiven a model, and some (collection of) variables X to optimize. an objective function f can be added as follows. Note that only Min for minimization us currently defined. Max will come soon.\n\n# Applies to all variables in order of insertion.\n# Recommended only when the function argument order does not matter.\n@objective(model, ScalarFunction(f))\n\n# Generic use\n@objective(model, ScalarFunction(f, X))\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.SequentialTasks","page":"Home","title":"CBLS.SequentialTasks","text":"Local constraint ensuring that, given a vector X of size 4, |X[1] - X[2]| ≠ |X[3] - X[4]|).\n\n@constraint(model, X in SequentialTasks())\n\n\n\n\n\n","category":"type"},{"location":"#CBLS.SumEqualParam","page":"Home","title":"CBLS.SumEqualParam","text":"Global constraint ensuring that the sum of the values of X is equal to a given parameter param.\n\n@constraint(model, X in SumEqualParam(param))\n\n\n\n\n\n","category":"type"},{"location":"#Base.copy-Tuple{CBLS.MOIError}","page":"Home","title":"Base.copy","text":"Base.copy(set::MOIError) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"#Base.copy-Tuple{DiscreteSet}","page":"Home","title":"Base.copy","text":"Base.copy(set::DiscreteSet) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"#JuMP.build_variable-Union{Tuple{T}, Tuple{Function, JuMP.VariableInfo, T}} where T<:MathOptInterface.AbstractScalarSet","page":"Home","title":"JuMP.build_variable","text":"JuMP.build_variable(::Function, info::JuMP.VariableInfo, set::T) where T <: MOI.AbstractScalarSet\n\nDOCSTRING\n\nArguments:\n\n``: DESCRIPTION\ninfo: DESCRIPTION\nset: DESCRIPTION\n\n\n\n\n\n","category":"method"},{"location":"#MathOptInterface.Utilities.supports_default_copy_to-Tuple{CBLS.Optimizer, Bool}","page":"Home","title":"MathOptInterface.Utilities.supports_default_copy_to","text":"Copy constructor for the optimizer\n\n\n\n\n\n","category":"method"},{"location":"#MathOptInterface.add_constraint-Union{Tuple{F}, Tuple{CBLS.Optimizer, MathOptInterface.VectorOfVariables, CBLS.MOIError{F}}} where F<:Function","page":"Home","title":"MathOptInterface.add_constraint","text":"MOI.add_constraint(optimizer::Optimizer, vars::MOI.VectorOfVariables, set::MOIError)\n\nDOCSTRING\n\nArguments:\n\noptimizer: DESCRIPTION\nvars: DESCRIPTION\nset: DESCRIPTION\n\n\n\n\n\n","category":"method"},{"location":"#MathOptInterface.add_constraint-Union{Tuple{T}, Tuple{CBLS.Optimizer, MathOptInterface.SingleVariable, DiscreteSet{T}}} where T<:Number","page":"Home","title":"MathOptInterface.add_constraint","text":"MOI.add_constraint(optimizer::Optimizer, v::SVF, set::DiscreteSet{T}) where T <: Number\n\nDOCSTRING\n\nArguments:\n\noptimizer: DESCRIPTION\nv: DESCRIPTION\nset: DESCRIPTION\n\n\n\n\n\n","category":"method"},{"location":"#MathOptInterface.add_variable-Tuple{CBLS.Optimizer}","page":"Home","title":"MathOptInterface.add_variable","text":"MOI.add_variable(model::Optimizer) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"#MathOptInterface.empty!-Tuple{Any}","page":"Home","title":"MathOptInterface.empty!","text":"MOI.empty!(opt) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"#MathOptInterface.get-Tuple{CBLS.Optimizer, MathOptInterface.SolverName}","page":"Home","title":"MathOptInterface.get","text":"MOI.get(::Optimizer, ::MOI.SolverName) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"#MathOptInterface.is_empty-Tuple{CBLS.Optimizer}","page":"Home","title":"MathOptInterface.is_empty","text":"MOI.is_empty(model::Optimizer) = begin\n\nDOCSTRING\n\n\n\n\n\n","category":"method"},{"location":"#MathOptInterface.optimize!-Tuple{CBLS.Optimizer}","page":"Home","title":"MathOptInterface.optimize!","text":"MOI.optimize!(model::Optimizer)\n\n\n\n\n\n","category":"method"},{"location":"#MathOptInterface.set","page":"Home","title":"MathOptInterface.set","text":"MOI.set(::Optimizer, ::MOI.Silent, bool = true) = begin\n\nDOCSTRING\n\nArguments:\n\n``: DESCRIPTION\n``: DESCRIPTION\nbool: DESCRIPTION\n\n\n\n\n\n","category":"function"},{"location":"#MathOptInterface.set-Tuple{CBLS.Optimizer, MathOptInterface.RawParameter, Any}","page":"Home","title":"MathOptInterface.set","text":"MOI.set(model::Optimizer, p::MOI.RawParameter, value)\n\nSet a RawParameter to value\n\n\n\n\n\n","category":"method"},{"location":"#MathOptInterface.set-Tuple{CBLS.Optimizer, MathOptInterface.TimeLimitSec, Union{Nothing, Float64}}","page":"Home","title":"MathOptInterface.set","text":"MOI.set(model::Optimizer, ::MOI.TimeLimitSec, value::Union{Nothing,Float64})\n\nSet the time limit\n\n\n\n\n\n","category":"method"},{"location":"#MathOptInterface.supports_constraint-Union{Tuple{F}, Tuple{CBLS.Optimizer, Type{MathOptInterface.VectorOfVariables}, Type{CBLS.MOIError{F}}}} where F<:Function","page":"Home","title":"MathOptInterface.supports_constraint","text":"MOI.supports_constraint(::Optimizer, ::Type{VOV}, ::Type{MOIError}) = begin\n\nDOCSTRING\n\nArguments:\n\n``: DESCRIPTION\n``: DESCRIPTION\n``: DESCRIPTION\n\n\n\n\n\n","category":"method"}]
}
